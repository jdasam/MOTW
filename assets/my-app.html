<!--
  <my-app>
  @description Boilerplate for the music app (from MOTW 2015 workshop)
  @version 0.0.1
-->


<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/spiral-knob/spiral-knob.html">
<link rel="import" href="../assets/motw-doc-header.html">

<dom-module id="my-app">
  

  <style>
    /* your style here */
    :host {
      display: block;
      margin: 1em;
      font-family: 'Roboto', 'Noto', sans-serif;
      color: #263238;
      -webkit-font-smoothing: antialiased;
      -webkit-user-select: none;
    }
  </style>

  <template>
    <!-- your DOM here -->
    <h1>Da's simple FM synthesizer</h1>
    <spiral-knob id="knobAmp" label="Amp" value="0"></spiral-knob>
    <spiral-knob id="knobFreq" label="Freq" value="400" min-value="0" max-value ="4000"></spiral-knob>
    <spiral-knob id="knobModFreq" label="Mod F" value="1200" min-value="0" max-value = "4000"></spiral-knob>
    <spiral-knob id="knobModAmp" label="Mod A" value="3000" min-value="0" max-value = "10000"></spiral-knob>
    <spiral-knob id="knobMod2Freq" label="Mod2 F" value="2400" min-value="0" max-value = "4000"></spiral-knob>
    <spiral-knob id="knobMod2Amp" label="Mod2 A" value="9000" min-value="0" max-value = "10000"></spiral-knob>
    <spiral-knob id="knobAMFreq" label="AM F" value="2000" min-value="0" max-value = "10000"></spiral-knob>
    <spiral-knob id="knobAMAmp" label="AM A" value="0.1" min-value="0" max-value = "1"></spiral-knob>


  </template>

  <script>
    Polymer({

      is: "my-app",

      /* user-defined properties */
      properties: {
        
        context: {
          type: Object,
          value: new AudioContext()
        }
        
      },

      /* user-defined methods */
      _buildAudioGraph: function () {
        this.context.createNodes(this, {
          'osc': 'Oscillator',
          'amp': 'Gain',
          'mod': 'Oscillator',
          'modAmp': 'Gain',
          'mod2': 'Oscillator',
          'mod2Amp': 'Gain',
          'AM': 'Oscillator',
          'AMAmp': 'Gain',
        });

        this.AM.to(this.AMAmp).to(this.amp.gain);
        this.mod2.to(this.mod2Amp).to(this.mod.frequency);
        this.mod.to(this.modAmp).to(this.osc.frequency);
        this.osc.to(this.amp).to(this.context.DAC);
        this.amp.value = 0.1;
        this.osc.start();
        this.mod.start();
        this.mod2.start();
        this.AM.start();
      },

      _bindUI: function () {
        this.$.knobAmp.bind(this.amp.gain);
        this.$.knobFreq.bind(this.osc.frequency);
        this.$.knobModFreq.bind(this.mod.frequency);
        this.$.knobModAmp.bind(this.modAmp.gain);
        this.$.knobMod2Freq.bind(this.mod2.frequency);
        this.$.knobMod2Amp.bind(this.mod2Amp.gain);
        this.$.knobAMFreq.bind(this.AM.frequency);
        this.$.knobAMAmp.bind(this.AMAmp.gain);
      },

      /* Polymer built-in event handlers */
      ready: function () {
        console.log('My app is ready!');
        this._buildAudioGraph();
        this._bindUI();
      },

      attached: function () {}

    });


    var synth = {
      noteOn: function (pitch, velocity) {
        
      },
      
      onmidimessage: function (message) {
        
      },
      
      
    };

    
    function onresolve(midiAccess){
      midiAccess.inputs.forEach(function (key, value) {
        console.log(key, value);
      });
      
    }

    function onreject(){
      console.log('Nein');
    }

    navigator.requestMIDIAccess().then(listInputsAndOutputs, onreject);
    
    function listInputsAndOutputs( midiAccess ) {
      for (var entry of midiAccess.inputs) {
        var input = entry[1];
        console.log( "Input port [type:'" + input.type + "'] id:'" + input.id +
          "' manufacturer:'" + input.manufacturer + "' name:'" + input.name +
          "' version:'" + input.version + "'" );
      }

      for (var entry of midiAccess.outputs) {
        var output = entry[1];
        console.log( "Output port [type:'" + output.type + "'] id:'" + output.id +
          "' manufacturer:'" + output.manufacturer + "' name:'" + output.name +
          "' version:'" + output.version + "'" );
      }
    }

    function onMIDIMessage( event ) {
      var str = "MIDI message received at timestamp " + event.timestamp + "[" + event.data.length + " bytes]: ";
      for (var i=0; i<event.data.length; i++) {
        str += "0x" + event.data[i].toString(16) + " ";
      }
      console.log( str );
    }

    function startLoggingMIDIInput( midiAccess, indexOfPort ) {
      midiAccess.inputs.forEach( function(entry) {entry.onmidimessage = onMIDIMessage;});
    }


    var context=null;   // the Web Audio "context" object
    var midiAccess=null;  // the MIDIAccess object.
    var oscillator=null;  // the single oscillator
    var envelope=null;    // the envelope for the single oscillator
    var attack=0.05;      // attack speed
    var release=0.05;   // release speed
    var portamento=0.05;  // portamento/glide speed
    var activeNotes = []; // the stack of actively-pressed keys

    window.addEventListener('load', function() {
      // patch up prefixes
      window.AudioContext=window.AudioContext||window.webkitAudioContext;

      context = new AudioContext();
      if (navigator.requestMIDIAccess)
        navigator.requestMIDIAccess().then( onMIDIInit, onMIDIReject );
      else
        alert("No MIDI support present in your browser.  You're gonna have a bad time.")

      // set up the basic oscillator chain, muted to begin with.
      oscillator = context.createOscillator();
      oscillator.frequency.setValueAtTime(110, 0);
      envelope = context.createGain();
      oscillator.connect(envelope);
      envelope.connect(context.destination);
      envelope.gain.value = 0.0;  // Mute the sound
      oscillator.start(0);  // Go ahead and start up the oscillator
    } );

    function onMIDIInit(midi) {
      midiAccess = midi;

      var haveAtLeastOneDevice=false;
      var inputs=midiAccess.inputs.values();
      for ( var input = inputs.next(); input && !input.done; input = inputs.next()) {
        input.value.onmidimessage = MIDIMessageEventHandler;
        haveAtLeastOneDevice = true;
      }
      if (!haveAtLeastOneDevice)
        alert("No MIDI input devices present.  You're gonna have a bad time.");
    }

    function onMIDIReject(err) {
      alert("The MIDI system failed to start.  You're gonna have a bad time.");
    }

    function MIDIMessageEventHandler(event) {
      // Mask off the lower nibble (MIDI channel, which we don't care about)
      switch (event.data[0] & 0xf0) {
        case 0x90:
          if (event.data[2]!=0) {  // if velocity != 0, this is a note-on message
            noteOn(event.data[1]);
            return;
          }
          // if velocity == 0, fall thru: it's a note-off.  MIDI's weird, y'all.
        case 0x80:
          noteOff(event.data[1]);
          return;
      }
    }

    function frequencyFromNoteNumber( note ) {
      return 440 * Math.pow(2,(note-69)/12);
    }

    function noteOn(noteNumber) {
      activeNotes.push( noteNumber );
      oscillator.frequency.cancelScheduledValues(0);
      oscillator.frequency.setTargetAtTime( frequencyFromNoteNumber(noteNumber), 0, portamento );
      envelope.gain.cancelScheduledValues(0);
      envelope.gain.setTargetAtTime(1.0, 0, attack);
    }

    function noteOff(noteNumber) {
      var position = activeNotes.indexOf(noteNumber);
      if (position!=-1) {
        activeNotes.splice(position,1);
      }
      if (activeNotes.length==0) {  // shut off the envelope
        envelope.gain.cancelScheduledValues(0);
        envelope.gain.setTargetAtTime(0.0, 0, release );
      } else {
        oscillator.frequency.cancelScheduledValues(0);
        oscillator.frequency.setTargetAtTime( frequencyFromNoteNumber(activeNotes[activeNotes.length-1]), 0, portamento );
      }
    }


  </script>

</dom-module>


